name: Simple Docker Deploy Pipeline

# Pipeline simplificado para desplegar solo la imagen Docker actualizada
on:
  push:
    branches:
      - main
  pull_request:
    branches:
      - main

env:
  AWS_DEFAULT_REGION: us-east-1
  ECR_REPOSITORY: amrize-ecr-repo
  IMAGE_TAG: ${{ github.sha }}

jobs:
  # Job 1: Build and Push Docker Image to ECR
  docker_build_push:
    name: "🚀 Build & Deploy Docker Image"
    runs-on: ubuntu-latest
    
    outputs:
      image_uri: ${{ steps.build-image.outputs.image }}
      image_tag: ${{ steps.build-image.outputs.tag }}
      
    steps:
      - name: 📥 Checkout Repository
        uses: actions/checkout@v4

      - name: 🔐 Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_DEFAULT_REGION }}

      - name: 🔐 Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: 📋 Get ECR Repository Info
        id: ecr-info
        run: |
          ECR_URI=$(aws ecr describe-repositories \
            --repository-names ${{ env.ECR_REPOSITORY }} \
            --region ${{ env.AWS_DEFAULT_REGION }} \
            --query 'repositories[0].repositoryUri' \
            --output text)
          echo "📦 ECR Repository URI: $ECR_URI"
          echo "ecr_uri=$ECR_URI" >> $GITHUB_OUTPUT

      - name: 🔨 Build, Tag & Push Docker Image with Updated HTML
        id: build-image
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          ECR_REPOSITORY: ${{ env.ECR_REPOSITORY }}
          IMAGE_TAG: ${{ env.IMAGE_TAG }}
        run: |
          echo "🏗️ Building Docker image with updated HTML content..."
          echo "📄 HTML content will be copied from ./public-html/ to container"
          
          # Build image with commit SHA tag
          docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG .
          
          # Tag as latest
          docker tag $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG $ECR_REGISTRY/$ECR_REPOSITORY:latest
          
          echo "⬆️ Pushing images to ECR..."
          
          # Push both tags
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:latest
          
          echo "✅ Images pushed successfully!"
          echo "🌐 Image URI: $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG"
          
          # Set outputs
          echo "image=$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG" >> $GITHUB_OUTPUT
          echo "tag=$IMAGE_TAG" >> $GITHUB_OUTPUT

      - name: 🧹 Cleanup Local Images
        run: |
          echo "🗑️ Cleaning up local Docker images..."
          docker rmi $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG || true
          docker rmi $ECR_REGISTRY/$ECR_REPOSITORY:latest || true
          docker system prune -f

  # Job 2: Update ECS Service with New Image
  ecs_update:
    name: "🔄 Update ECS Service"
    runs-on: ubuntu-latest
    needs: docker_build_push
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    
    steps:
      - name: 🔐 Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_DEFAULT_REGION }}

      - name: 📋 Check Current ECS Service Status
        run: |
          echo "🔍 Checking current ECS service status..."
          aws ecs describe-services \
            --cluster amrize-ecs-cluster \
            --services apache-service \
            --query 'services[0].{Status:status,RunningCount:runningCount,DesiredCount:desiredCount,CurrentImage:taskDefinition}' \
            --output table

      - name: 🔄 Force ECS Service Update with New Image
        run: |
          echo "🚀 Updating ECS service with new image: ${{ needs.docker_build_push.outputs.image_uri }}"
          
          # Force new deployment - this will pull the latest image from ECR
          aws ecs update-service \
            --cluster amrize-ecs-cluster \
            --service apache-service \
            --force-new-deployment

      - name: ⏳ Wait for Service Stability
        run: |
          echo "⏳ Waiting for ECS service to stabilize with new image..."
          aws ecs wait services-stable \
            --cluster amrize-ecs-cluster \
            --services apache-service \
            --cli-read-timeout 600 \
            --cli-connect-timeout 60

      - name: ✅ Verify Service Update
        run: |
          echo "✅ Verifying service deployment..."
          aws ecs describe-services \
            --cluster amrize-ecs-cluster \
            --services apache-service \
            --query 'services[0].{Status:status,RunningCount:runningCount,DesiredCount:desiredCount,TaskDefinition:taskDefinition}' \
            --output table

  # Job 3: Verify Application is Running
  verify_deployment:
    name: "✅ Verify Application"
    runs-on: ubuntu-latest
    needs: [docker_build_push, ecs_update]
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    
    steps:
      - name: 🔐 Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_DEFAULT_REGION }}

      - name: 🌐 Get ALB URL and Test Application
        run: |
          echo "🔍 Getting ALB URL..."
          
          # Get ALB DNS name
          ALB_DNS=$(aws elbv2 describe-load-balancers \
            --names amrize-apache-alb \
            --query 'LoadBalancers[0].DNSName' \
            --output text 2>/dev/null || echo "")
          
          if [ -n "$ALB_DNS" ] && [ "$ALB_DNS" != "None" ]; then
            ALB_URL="http://$ALB_DNS"
            echo "🌐 Testing application at: $ALB_URL"
            
            # Test endpoint with retries
            max_attempts=20
            attempt=0
            
            while [ $attempt -lt $max_attempts ]; do
              attempt=$((attempt + 1))
              echo "🔄 Testing endpoint (attempt $attempt/$max_attempts)..."
              
              if curl -f -s "$ALB_URL" > /dev/null; then
                echo "✅ Application is responding successfully!"
                echo "📄 Application content:"
                curl -s "$ALB_URL" | head -10
                break
              else
                echo "⏳ Waiting for application to be ready..."
                sleep 15
              fi
            done
            
          else
            echo "⚠️ ALB not found or not accessible, checking ECS service health instead..."
            aws ecs describe-services \
              --cluster amrize-ecs-cluster \
              --services apache-service \
              --query 'services[0].{Status:status,HealthyTargets:runningCount}' \
              --output table
          fi

      - name: 🎉 Deployment Summary
        run: |
          echo "════════════════════════════════════════"
          echo "🎉 DEPLOYMENT COMPLETED SUCCESSFULLY! 🎉"
          echo "════════════════════════════════════════"
          echo ""
          echo "📦 Deployed Image: ${{ needs.docker_build_push.outputs.image_uri }}"
          echo "🏷️ Image Tag: ${{ needs.docker_build_push.outputs.image_tag }}"
          echo "🔄 ECS Service: apache-service updated"
          echo "🏗️ ECS Cluster: amrize-ecs-cluster"
          echo ""
          echo "✅ Updated HTML content deployed to production!"
          echo "🚀 Application is ready to serve traffic!"

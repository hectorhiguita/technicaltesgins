name: Simple Docker Deploy Pipeline

# Pipeline simplificado para desplegar solo la imagen Docker actualizada
on:
  push:
    branches:
      - main
  pull_request:
    branches:
      - main

env:
  AWS_DEFAULT_REGION: us-east-1
  ECR_REPOSITORY: amrize-ecr-repo
  IMAGE_TAG: ${{ github.sha }}

jobs:
  # Job 1: Build and Push Docker Image to ECR
  docker_build_push:
    name: "ğŸš€ Build & Deploy Docker Image"
    runs-on: ubuntu-latest
    
    outputs:
      image_uri: ${{ steps.build-image.outputs.image }}
      image_tag: ${{ steps.build-image.outputs.tag }}
      
    steps:
      - name: ğŸ“¥ Checkout Repository
        uses: actions/checkout@v4

      - name: ğŸ” Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_DEFAULT_REGION }}

      - name: ğŸ” Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: ğŸ“‹ Get ECR Repository Info
        id: ecr-info
        run: |
          ECR_URI=$(aws ecr describe-repositories \
            --repository-names ${{ env.ECR_REPOSITORY }} \
            --region ${{ env.AWS_DEFAULT_REGION }} \
            --query 'repositories[0].repositoryUri' \
            --output text)
          echo "ğŸ“¦ ECR Repository URI: $ECR_URI"
          echo "ecr_uri=$ECR_URI" >> $GITHUB_OUTPUT

      - name: ğŸ”¨ Build, Tag & Push Docker Image with Updated HTML
        id: build-image
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          ECR_REPOSITORY: ${{ env.ECR_REPOSITORY }}
          IMAGE_TAG: ${{ env.IMAGE_TAG }}
        run: |
          echo "ğŸ—ï¸ Building Docker image with updated HTML content..."
          echo "ğŸ“„ HTML content will be copied from ./public-html/ to container"
          
          # Build image with commit SHA tag
          docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG .
          
          # Tag as latest
          docker tag $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG $ECR_REGISTRY/$ECR_REPOSITORY:latest
          
          echo "â¬†ï¸ Pushing images to ECR..."
          
          # Push both tags
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:latest
          
          echo "âœ… Images pushed successfully!"
          echo "ğŸŒ Image URI: $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG"
          
          # Set outputs
          echo "image=$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG" >> $GITHUB_OUTPUT
          echo "tag=$IMAGE_TAG" >> $GITHUB_OUTPUT

      - name: ğŸ§¹ Cleanup Local Images
        run: |
          echo "ğŸ—‘ï¸ Cleaning up local Docker images..."
          docker rmi $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG || true
          docker rmi $ECR_REGISTRY/$ECR_REPOSITORY:latest || true
          docker system prune -f

  # Job 2: Update ECS Service with New Image
  ecs_update:
    name: "ğŸ”„ Update ECS Service"
    runs-on: ubuntu-latest
    needs: docker_build_push
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    
    steps:
      - name: ğŸ” Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_DEFAULT_REGION }}

      - name: ğŸ› ï¸ Install jq
        run: |
          echo "ğŸ“¦ Installing jq for JSON manipulation..."
          sudo apt-get update && sudo apt-get install -y jq

      - name: ğŸ“‹ Check Current ECS Service Status
        run: |
          echo "ğŸ” Checking current ECS service status..."
          aws ecs describe-services \
            --cluster cluster-backend-holcim-images \
            --services ui \
            --query 'services[0].{Status:status,RunningCount:runningCount,DesiredCount:desiredCount,CurrentImage:taskDefinition}' \
            --output table

      - name: ï¿½ Create New Task Definition with Updated Image
        run: |
          echo "ğŸ“ Creating new task definition with image: ${{ needs.docker_build_push.outputs.image_uri }}"
          
          # Get current task definition
          CURRENT_TASK_DEF=$(aws ecs describe-services \
            --cluster cluster-backend-holcim-images \
            --services ui \
            --query 'services[0].taskDefinition' \
            --output text)
          
          echo "Current task definition: $CURRENT_TASK_DEF"
          
          # Get task definition details
          aws ecs describe-task-definition \
            --task-definition "$CURRENT_TASK_DEF" \
            --query 'taskDefinition' > current_task_def.json
          
          # Update the image in the container definition
          jq --arg image "${{ needs.docker_build_push.outputs.image_uri }}" \
             '.containerDefinitions[0].image = $image' \
             current_task_def.json > updated_task_def.json
          
          # Remove fields that shouldn't be in the new task definition
          jq 'del(.taskDefinitionArn, .revision, .status, .requiresAttributes, .placementConstraints, .compatibilities, .registeredAt, .registeredBy)' \
             updated_task_def.json > new_task_def.json
          
          # Register new task definition
          NEW_TASK_ARN=$(aws ecs register-task-definition \
            --cli-input-json file://new_task_def.json \
            --query 'taskDefinition.taskDefinitionArn' \
            --output text)
          
          echo "âœ… New task definition created: $NEW_TASK_ARN"
          echo "NEW_TASK_ARN=$NEW_TASK_ARN" >> $GITHUB_ENV

      - name: ğŸ”„ Update ECS Service with New Task Definition
        run: |
          echo "ğŸš€ Updating ECS service with new task definition: $NEW_TASK_ARN"
          
          # Update service with new task definition
          aws ecs update-service \
            --cluster cluster-backend-holcim-images \
            --service ui \
            --task-definition "$NEW_TASK_ARN" \
            --force-new-deployment

      - name: â³ Wait for Service Stability
        run: |
          echo "â³ Waiting for ECS service to stabilize with new image..."
          aws ecs wait services-stable \
            --cluster cluster-backend-holcim-images \
            --services ui \
            --cli-read-timeout 600 \
            --cli-connect-timeout 60

      - name: âœ… Verify Service Update
        run: |
          echo "âœ… Verifying service deployment..."
          aws ecs describe-services \
            --cluster cluster-backend-holcim-images \
            --services ui \
            --query 'services[0].{Status:status,RunningCount:runningCount,DesiredCount:desiredCount,TaskDefinition:taskDefinition}' \
            --output table

  # Job 3: Verify Application is Running
  verify_deployment:
    name: "âœ… Verify Application"
    runs-on: ubuntu-latest
    needs: [docker_build_push, ecs_update]
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    
    steps:
      - name: ğŸ” Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_DEFAULT_REGION }}

      - name: ğŸŒ Get Service URL and Test Application
        run: |
          echo "ğŸ” Getting ECS service endpoint..."
          
          # Get target group ARN from service
          TG_ARN=$(aws ecs describe-services \
            --cluster cluster-backend-holcim-images \
            --services ui \
            --query 'services[0].loadBalancers[0].targetGroupArn' \
            --output text)
          
          if [ "$TG_ARN" != "None" ] && [ -n "$TG_ARN" ]; then
            echo "ğŸ¯ Target Group: $TG_ARN"
            
            # Get load balancer from target group
            LB_ARN=$(aws elbv2 describe-target-groups \
              --target-group-arns "$TG_ARN" \
              --query 'TargetGroups[0].LoadBalancerArns[0]' \
              --output text 2>/dev/null || echo "")
            
            if [ -n "$LB_ARN" ] && [ "$LB_ARN" != "None" ]; then
              # Get ALB DNS name
              ALB_DNS=$(aws elbv2 describe-load-balancers \
                --load-balancer-arns "$LB_ARN" \
                --query 'LoadBalancers[0].DNSName' \
                --output text 2>/dev/null || echo "")
              
              if [ -n "$ALB_DNS" ] && [ "$ALB_DNS" != "None" ]; then
                ALB_URL="http://$ALB_DNS"
                echo "ğŸŒ Testing application at: $ALB_URL"
                
                # Test endpoint with retries
                max_attempts=10
                attempt=0
                
                while [ $attempt -lt $max_attempts ]; do
                  attempt=$((attempt + 1))
                  echo "ğŸ”„ Testing endpoint (attempt $attempt/$max_attempts)..."
                  
                  if curl -f -s "$ALB_URL" > /dev/null; then
                    echo "âœ… Application is responding successfully!"
                    echo "ğŸ“„ Application content:"
                    curl -s "$ALB_URL" | head -10
                    break
                  else
                    echo "â³ Waiting for application to be ready..."
                    sleep 15
                  fi
                done
              else
                echo "âš ï¸ Load balancer DNS not found"
              fi
            else
              echo "âš ï¸ Load balancer not found for target group"
            fi
          else
            echo "âš ï¸ No load balancer configured for this service"
            echo "âœ… Checking ECS service health instead..."
            aws ecs describe-services \
              --cluster cluster-backend-holcim-images \
              --services ui \
              --query 'services[0].{Status:status,HealthyTargets:runningCount,DesiredCount:desiredCount}' \
              --output table
          fi

      - name: ğŸ‰ Deployment Summary
        run: |
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo "ğŸ‰ DEPLOYMENT COMPLETED SUCCESSFULLY! ğŸ‰"
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo ""
          echo "ğŸ“¦ Deployed Image: ${{ needs.docker_build_push.outputs.image_uri }}"
          echo "ğŸ·ï¸ Image Tag: ${{ needs.docker_build_push.outputs.image_tag }}"
          echo "ğŸ”„ ECS Service: ui updated"
          echo "ğŸ—ï¸ ECS Cluster: cluster-backend-holcim-images"
          echo ""
          echo "âœ… Updated HTML content deployed to production!"
          echo "ğŸš€ Application is ready to serve traffic!"

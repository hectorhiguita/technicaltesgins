name: Simple Docker Deploy Pipeline

# Pipeline simplificado para desplegar solo la imagen Docker actualizada
on:
  push:
    branches:
      - main
  pull_request:
    branches:
      - main

env:
  AWS_DEFAULT_REGION: us-east-1
  ECR_REPOSITORY: amrize-ecr-repo
  IMAGE_TAG: ${{ github.sha }}

jobs:
  # Job 1: Build and Push Docker Image to ECR
  docker_build_push:
    name: "ğŸš€ Build & Deploy Docker Image"
    runs-on: ubuntu-latest
    
    outputs:
      image_uri: ${{ steps.build-image.outputs.image }}
      image_tag: ${{ steps.build-image.outputs.tag }}
      
    steps:
      - name: ğŸ“¥ Checkout Repository
        uses: actions/checkout@v4

      - name: ğŸ” Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_DEFAULT_REGION }}

      - name: ğŸ” Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: ğŸ“‹ Get ECR Repository Info
        id: ecr-info
        run: |
          ECR_URI=$(aws ecr describe-repositories \
            --repository-names ${{ env.ECR_REPOSITORY }} \
            --region ${{ env.AWS_DEFAULT_REGION }} \
            --query 'repositories[0].repositoryUri' \
            --output text)
          echo "ğŸ“¦ ECR Repository URI: $ECR_URI"
          echo "ecr_uri=$ECR_URI" >> $GITHUB_OUTPUT

      - name: ğŸ”¨ Build, Tag & Push Docker Image with Updated HTML
        id: build-image
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          ECR_REPOSITORY: ${{ env.ECR_REPOSITORY }}
          IMAGE_TAG: ${{ env.IMAGE_TAG }}
        run: |
          echo "ğŸ—ï¸ Building Docker image with updated HTML content..."
          echo "ğŸ“„ HTML content will be copied from ./public-html/ to container"
          
          # Build image with commit SHA tag
          docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG .
          
          # Tag as latest
          docker tag $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG $ECR_REGISTRY/$ECR_REPOSITORY:latest
          
          echo "â¬†ï¸ Pushing images to ECR..."
          
          # Push both tags
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:latest
          
          echo "âœ… Images pushed successfully!"
          echo "ğŸŒ Image URI: $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG"
          
          # Set outputs
          echo "image=$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG" >> $GITHUB_OUTPUT
          echo "tag=$IMAGE_TAG" >> $GITHUB_OUTPUT

      - name: ğŸ§¹ Cleanup Local Images
        run: |
          echo "ğŸ—‘ï¸ Cleaning up local Docker images..."
          docker rmi $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG || true
          docker rmi $ECR_REGISTRY/$ECR_REPOSITORY:latest || true
          docker system prune -f

  # Job 2: Update ECS Service with New Image
  ecs_update:
    name: "ğŸ”„ Update ECS Service"
    runs-on: ubuntu-latest
    needs: docker_build_push
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    
    steps:
      - name: ğŸ” Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_DEFAULT_REGION }}

      - name: ğŸ“‹ Check Current ECS Service Status
        run: |
          echo "ğŸ” Checking current ECS service status..."
          aws ecs describe-services \
            --cluster amrize-ecs-cluster \
            --services apache-service \
            --query 'services[0].{Status:status,RunningCount:runningCount,DesiredCount:desiredCount,CurrentImage:taskDefinition}' \
            --output table

      - name: ğŸ”„ Force ECS Service Update with New Image
        run: |
          echo "ğŸš€ Updating ECS service with new image: ${{ needs.docker_build_push.outputs.image_uri }}"
          
          # Force new deployment - this will pull the latest image from ECR
          aws ecs update-service \
            --cluster amrize-ecs-cluster \
            --service apache-service \
            --force-new-deployment

      - name: â³ Wait for Service Stability
        run: |
          echo "â³ Waiting for ECS service to stabilize with new image..."
          aws ecs wait services-stable \
            --cluster amrize-ecs-cluster \
            --services apache-service \
            --cli-read-timeout 600 \
            --cli-connect-timeout 60

      - name: âœ… Verify Service Update
        run: |
          echo "âœ… Verifying service deployment..."
          aws ecs describe-services \
            --cluster amrize-ecs-cluster \
            --services apache-service \
            --query 'services[0].{Status:status,RunningCount:runningCount,DesiredCount:desiredCount,TaskDefinition:taskDefinition}' \
            --output table

  # Job 3: Verify Application is Running
  verify_deployment:
    name: "âœ… Verify Application"
    runs-on: ubuntu-latest
    needs: [docker_build_push, ecs_update]
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    
    steps:
      - name: ğŸ” Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_DEFAULT_REGION }}

      - name: ğŸŒ Get ALB URL and Test Application
        run: |
          echo "ğŸ” Getting ALB URL..."
          
          # Get ALB DNS name
          ALB_DNS=$(aws elbv2 describe-load-balancers \
            --names amrize-apache-alb \
            --query 'LoadBalancers[0].DNSName' \
            --output text 2>/dev/null || echo "")
          
          if [ -n "$ALB_DNS" ] && [ "$ALB_DNS" != "None" ]; then
            ALB_URL="http://$ALB_DNS"
            echo "ğŸŒ Testing application at: $ALB_URL"
            
            # Test endpoint with retries
            max_attempts=20
            attempt=0
            
            while [ $attempt -lt $max_attempts ]; do
              attempt=$((attempt + 1))
              echo "ğŸ”„ Testing endpoint (attempt $attempt/$max_attempts)..."
              
              if curl -f -s "$ALB_URL" > /dev/null; then
                echo "âœ… Application is responding successfully!"
                echo "ğŸ“„ Application content:"
                curl -s "$ALB_URL" | head -10
                break
              else
                echo "â³ Waiting for application to be ready..."
                sleep 15
              fi
            done
            
          else
            echo "âš ï¸ ALB not found or not accessible, checking ECS service health instead..."
            aws ecs describe-services \
              --cluster amrize-ecs-cluster \
              --services apache-service \
              --query 'services[0].{Status:status,HealthyTargets:runningCount}' \
              --output table
          fi

      - name: ğŸ‰ Deployment Summary
        run: |
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo "ğŸ‰ DEPLOYMENT COMPLETED SUCCESSFULLY! ğŸ‰"
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo ""
          echo "ğŸ“¦ Deployed Image: ${{ needs.docker_build_push.outputs.image_uri }}"
          echo "ğŸ·ï¸ Image Tag: ${{ needs.docker_build_push.outputs.image_tag }}"
          echo "ğŸ”„ ECS Service: apache-service updated"
          echo "ğŸ—ï¸ ECS Cluster: amrize-ecs-cluster"
          echo ""
          echo "âœ… Updated HTML content deployed to production!"
          echo "ğŸš€ Application is ready to serve traffic!"

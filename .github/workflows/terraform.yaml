name: Complete Infrastructure and Application Deployment

# Se ejecuta el workflow cuando se haga un push a la rama 'main'
# o cuando se cree un Pull Request a la rama 'main'.
on:
  push:
    branches:
      - main
  pull_request:
    branches:
      - main

env:
  AWS_DEFAULT_REGION: us-east-1
  ECR_REPOSITORY: amrize-ecr-repo
  IMAGE_TAG: ${{ github.sha }}

jobs:
  # Job 1: Build and Push Docker Image to ECR
  docker_build_push:
    name: "ğŸš€ Build & Push Docker Image to ECR"
    runs-on: ubuntu-latest
    
    outputs:
      image_uri: ${{ steps.build-image.outputs.image }}
      image_tag: ${{ steps.build-image.outputs.tag }}
      ecr_registry: ${{ steps.login-ecr.outputs.registry }}
      
    steps:
      - name: ğŸ“¥ Checkout Repository
        uses: actions/checkout@v4

      - name: ğŸ”§ Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_DEFAULT_REGION }}

      - name: ğŸ” Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: ğŸ“‹ Get ECR Repository Info
        id: ecr-info
        run: |
          # Verificar que el repositorio ECR existe
          ECR_URI=$(aws ecr describe-repositories \
            --repository-names ${{ env.ECR_REPOSITORY }} \
            --region ${{ env.AWS_DEFAULT_REGION }} \
            --query 'repositories[0].repositoryUri' \
            --output text)
          echo "ğŸ“¦ ECR Repository URI: $ECR_URI"
          echo "ecr_uri=$ECR_URI" >> $GITHUB_OUTPUT

      - name: ğŸ”¨ Build, Tag & Push Docker Image
        id: build-image
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          ECR_REPOSITORY: ${{ env.ECR_REPOSITORY }}
          IMAGE_TAG: ${{ env.IMAGE_TAG }}
        run: |
          echo "ğŸ—ï¸ Building Docker image..."
          
          # Build image with commit SHA tag
          docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG .
          
          # Tag as latest
          docker tag $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG $ECR_REGISTRY/$ECR_REPOSITORY:latest
          
          echo "â¬†ï¸ Pushing images to ECR..."
          
          # Push both tags
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:latest
          
          echo "âœ… Images pushed successfully!"
          echo "ğŸŒ Image URI: $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG"
          
          # Set outputs
          echo "image=$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG" >> $GITHUB_OUTPUT
          echo "tag=$IMAGE_TAG" >> $GITHUB_OUTPUT

      - name: ğŸ§¹ Cleanup Local Images
        run: |
          echo "ğŸ—‘ï¸ Cleaning up local Docker images..."
          docker rmi $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG || true
          docker rmi $ECR_REGISTRY/$ECR_REPOSITORY:latest || true
          docker system prune -f

  # Job 2: Deploy Infrastructure with Terraform
  terraform_deploy:
    name: "ğŸ—ï¸ Terraform Infrastructure Deployment"
    runs-on: ubuntu-latest
    needs: docker_build_push  # Wait for Docker image to be built
    
    outputs:
      alb_url: ${{ steps.terraform-output.outputs.alb_url }}
      ecs_cluster: ${{ steps.terraform-output.outputs.ecs_cluster }}
      
    env:
      TF_ROOT: ${{ github.workspace }}
      AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
      AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
      TF_STATE_BUCKET_NAME: ${{ secrets.TF_STATE_BUCKET_NAME }}
      TF_STATE_KEY_PREFIX: ${{ secrets.TF_STATE_KEY_PREFIX }}

    steps:
      - name: ğŸ“¥ Checkout Repository
        uses: actions/checkout@v4

      - name: ğŸ”§ Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.x.x
          terraform_wrapper: false  # Disable wrapper for clean outputs

      - name: ğŸ” Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ env.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ env.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_DEFAULT_REGION }}

      - name: ğŸ”„ Update ECS Task Definition with New Image
        run: |
          echo "ğŸ–¼ï¸ Updating ECS task definition with new image..."
          echo "New image URI: ${{ needs.docker_build_push.outputs.image_uri }}"
          
          # Create backup of current ecs.tf
          cp Modules/ECS/ecs.tf Modules/ECS/ecs.tf.backup
          
          # Update the image in ecs.tf with the newly built image
          sed -i 's|image[[:space:]]*=[[:space:]]*"[^"]*"|image = "${{ needs.docker_build_push.outputs.image_uri }}"|g' Modules/ECS/ecs.tf
          
          # Verify the change
          echo "ğŸ“‹ Checking updated image configuration:"
          grep -n "image.*=" Modules/ECS/ecs.tf || echo "No image configuration found"

      - name: ğŸ”„ Terraform Init
        id: init
        run: |
          echo "ğŸš€ Initializing Terraform..."
          terraform init \
            -backend-config="bucket=${{ env.TF_STATE_BUCKET_NAME }}" \
            -backend-config="key=${{ env.TF_STATE_KEY_PREFIX }}/${{ github.ref_name }}.tfstate" \
            -backend-config="region=${{ env.AWS_DEFAULT_REGION }}"

      - name: âœ… Terraform Validate
        id: validate
        run: |
          echo "ğŸ” Validating Terraform configuration..."
          terraform validate -no-color

      - name: ğŸ“‹ Terraform Plan
        id: plan
        run: |
          echo "ğŸ“Š Creating Terraform execution plan..."
          terraform plan -no-color -out=tfplan
          
      - name: ğŸ’¾ Save Terraform Plan Output
        if: github.event_name == 'pull_request'
        run: |
          terraform show -no-color tfplan > tfplan.txt
          
      - name: ğŸ“ Comment PR with Terraform Plan
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const plan = fs.readFileSync('tfplan.txt', 'utf8');
            const maxLength = 65000; // GitHub comment limit
            const truncatedPlan = plan.length > maxLength ? 
              plan.substring(0, maxLength) + '\n\n... (truncated)' : plan;
              
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: `## ğŸ—ï¸ Terraform Plan Results\n\n**New Docker Image:** \`${{ needs.docker_build_push.outputs.image_uri }}\`\n\n\`\`\`hcl\n${truncatedPlan}\n\`\`\``
            });

      - name: ğŸš€ Terraform Apply
        if: github.event_name == 'push' && github.ref == 'refs/heads/main'
        run: |
          echo "ğŸ—ï¸ Applying Terraform changes..."
          terraform apply -auto-approve tfplan

      - name: ğŸ“Š Get Terraform Outputs
        if: github.event_name == 'push' && github.ref == 'refs/heads/main'
        id: terraform-output
        run: |
          echo "ğŸ“‹ Retrieving Terraform outputs..."
          ALB_URL=$(terraform output -raw alb_url)
          ECS_CLUSTER=$(terraform output -raw ecs_cluster_name)
          
          echo "ğŸŒ ALB URL: $ALB_URL"
          echo "ğŸ—ï¸ ECS Cluster: $ECS_CLUSTER"
          
          echo "alb_url=$ALB_URL" >> $GITHUB_OUTPUT
          echo "ecs_cluster=$ECS_CLUSTER" >> $GITHUB_OUTPUT

  # Job 3: Update ECS Service (Force new deployment)
  ecs_update:
    name: "ğŸ”„ Update ECS Service"
    runs-on: ubuntu-latest
    needs: [docker_build_push, terraform_deploy]
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    
    steps:
      - name: ğŸ” Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_DEFAULT_REGION }}

      - name: ğŸ“‹ Check ECS Service Status
        run: |
          echo "ğŸ” Checking current ECS service status..."
          aws ecs describe-services \
            --cluster amrize-ecs-cluster \
            --services apache-service \
            --query 'services[0].{Status:status,RunningCount:runningCount,DesiredCount:desiredCount}' \
            --output table

      - name: ğŸ”„ Force ECS Service Update
        run: |
          echo "ğŸš€ Forcing new deployment with image: ${{ needs.docker_build_push.outputs.image_uri }}"
          aws ecs update-service \
            --cluster amrize-ecs-cluster \
            --service apache-service \
            --force-new-deployment

      - name: â³ Wait for Service Stability
        run: |
          echo "â³ Waiting for ECS service to stabilize..."
          aws ecs wait services-stable \
            --cluster amrize-ecs-cluster \
            --services apache-service \
            --cli-read-timeout 900 \
            --cli-connect-timeout 60

      - name: âœ… Verify Service Update
        run: |
          echo "âœ… Verifying service deployment..."
          aws ecs describe-services \
            --cluster amrize-ecs-cluster \
            --services apache-service \
            --query 'services[0].{Status:status,RunningCount:runningCount,DesiredCount:desiredCount,TaskDefinition:taskDefinition}' \
            --output table

  # Job 4: Post-Deployment Verification
  verify_deployment:
    name: "âœ… Verify Deployment"
    runs-on: ubuntu-latest
    needs: [docker_build_push, terraform_deploy, ecs_update]
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    
    steps:
      - name: ğŸŒ Test Application Endpoint
        run: |
          ALB_URL="${{ needs.terraform_deploy.outputs.alb_url }}"
          echo "ğŸ” Testing application at: $ALB_URL"
          
          # Function to test endpoint
          test_endpoint() {
            local url=$1
            local response=$(curl -s -o /dev/null -w "%{http_code}" "$url" || echo "000")
            echo "$response"
          }
          
          # Wait for ALB to be ready with exponential backoff
          max_attempts=30
          attempt=0
          sleep_time=10
          
          while [ $attempt -lt $max_attempts ]; do
            attempt=$((attempt + 1))
            
            echo "ğŸ”„ Testing endpoint (attempt $attempt/$max_attempts)..."
            
            response_code=$(test_endpoint "$ALB_URL")
            
            if [ "$response_code" = "200" ]; then
              echo "âœ… Application is responding successfully! (HTTP $response_code)"
              
              # Get actual content to verify
              echo "ğŸ“„ Application response:"
              curl -s "$ALB_URL" | head -10
              break
              
            elif [ "$response_code" = "000" ]; then
              echo "âš ï¸ Connection failed (attempt $attempt/$max_attempts)"
            else
              echo "âš ï¸ Received HTTP $response_code (attempt $attempt/$max_attempts)"
            fi
            
            if [ $attempt -lt $max_attempts ]; then
              echo "â³ Waiting ${sleep_time}s before next attempt..."
              sleep $sleep_time
              
              # Exponential backoff (but cap at 60s)
              if [ $sleep_time -lt 60 ]; then
                sleep_time=$((sleep_time + 5))
              fi
            fi
          done
          
          # Final verification
          echo "ğŸ” Final endpoint test..."
          final_response=$(test_endpoint "$ALB_URL")
          
          if [ "$final_response" = "200" ]; then
            echo "âœ… Final test passed!"
          else
            echo "âŒ Final test failed with HTTP code: $final_response"
            echo "ğŸ” Debugging information:"
            curl -v "$ALB_URL" || true
            exit 1
          fi

      - name: ğŸ¥ Health Check Summary
        run: |
          echo "ğŸ¥ Performing final health checks..."
          
          # Check ECS service health
          echo "ğŸ“Š ECS Service Status:"
          aws ecs describe-services \
            --cluster amrize-ecs-cluster \
            --services apache-service \
            --query 'services[0].{Status:status,RunningCount:runningCount,DesiredCount:desiredCount}' \
            --output table
          
          # Check ALB target health
          echo "ğŸ¯ ALB Target Health:"
          TARGET_GROUP_ARN=$(aws elbv2 describe-target-groups \
            --names amrize-apache-target-group \
            --query 'TargetGroups[0].TargetGroupArn' \
            --output text 2>/dev/null || echo "Not found")
          
          if [ "$TARGET_GROUP_ARN" != "Not found" ] && [ "$TARGET_GROUP_ARN" != "None" ]; then
            aws elbv2 describe-target-health \
              --target-group-arn "$TARGET_GROUP_ARN" \
              --query 'TargetHealthDescriptions[*].{Target:Target.Id,Port:Target.Port,Health:TargetHealth.State}' \
              --output table
          else
            echo "âš ï¸ Target group not found or not accessible"
          fi

      - name: ğŸš€ Deployment Summary
        run: |
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo "ğŸš€ DEPLOYMENT COMPLETED SUCCESSFULLY! ğŸš€"
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo ""
          echo "ğŸ“¦ Deployed Image: ${{ needs.docker_build_push.outputs.image_uri }}"
          echo "ğŸ·ï¸ Image Tag: ${{ needs.docker_build_push.outputs.image_tag }}"
          echo "ğŸŒ Application URL: ${{ needs.terraform_deploy.outputs.alb_url }}"
          echo "ğŸ—ï¸ ECS Cluster: ${{ needs.terraform_deploy.outputs.ecs_cluster }}"
          echo ""
          echo "ğŸ”— Quick Links:"
          echo "â€¢ Application: ${{ needs.terraform_deploy.outputs.alb_url }}"
          echo "â€¢ ECR Repository: https://console.aws.amazon.com/ecr/repositories/private/${{ needs.docker_build_push.outputs.ecr_registry }}/${{ env.ECR_REPOSITORY }}"
          echo "â€¢ ECS Service: https://console.aws.amazon.com/ecs/home?region=${{ env.AWS_DEFAULT_REGION }}#/clusters/amrize-ecs-cluster/services"
          echo ""
          echo "âœ… All systems operational!"

  # Job 5: Cleanup and Error Handling
  cleanup_on_failure:
    name: "ğŸ§¹ Cleanup on Failure"
    runs-on: ubuntu-latest
    needs: [docker_build_push, terraform_deploy, ecs_update, verify_deployment]
    if: failure() && github.event_name == 'push' && github.ref == 'refs/heads/main'
    
    steps:
      - name: ğŸ“¥ Checkout Repository
        uses: actions/checkout@v4

      - name: ğŸ” Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_DEFAULT_REGION }}

      - name: ğŸ”„ Rollback ECS Service
        if: needs.ecs_update.result == 'failure'
        run: |
          echo "ğŸ”„ Rolling back ECS service to previous task definition..."
          
          # Get current task definition
          CURRENT_TASK_DEF=$(aws ecs describe-services \
            --cluster amrize-ecs-cluster \
            --services apache-service \
            --query 'services[0].taskDefinition' \
            --output text)
          
          echo "Current task definition: $CURRENT_TASK_DEF"
          
          # Get task definition family
          FAMILY=$(echo $CURRENT_TASK_DEF | sed 's/.*\///g' | sed 's/:.*//')
          
          # Get previous revision
          PREVIOUS_REVISION=$(aws ecs list-task-definitions \
            --family-prefix $FAMILY \
            --status ACTIVE \
            --sort DESC \
            --query 'taskDefinitionArns[1]' \
            --output text)
          
          if [ "$PREVIOUS_REVISION" != "None" ] && [ "$PREVIOUS_REVISION" != "" ]; then
            echo "Rolling back to: $PREVIOUS_REVISION"
            aws ecs update-service \
              --cluster amrize-ecs-cluster \
              --service apache-service \
              --task-definition $PREVIOUS_REVISION
          else
            echo "âš ï¸ No previous task definition found for rollback"
          fi

      - name: ğŸ—‘ï¸ Cleanup Failed Docker Image
        if: needs.docker_build_push.result == 'failure'
        run: |
          echo "ğŸ—‘ï¸ Cleaning up potentially corrupted ECR image..."
          
          # Try to delete the failed image tag
          aws ecr batch-delete-image \
            --repository-name ${{ env.ECR_REPOSITORY }} \
            --image-ids imageTag=${{ env.IMAGE_TAG }} \
            --region ${{ env.AWS_DEFAULT_REGION }} || true

      - name: ğŸ“§ Notify Failure
        uses: actions/github-script@v7
        with:
          script: |
            const { owner, repo } = context.repo;
            const { sha } = context;
            
            // Create a deployment status
            await github.rest.repos.createDeploymentStatus({
              owner,
              repo,
              deployment_id: context.runId,
              state: 'failure',
              description: 'Deployment failed - automatic rollback initiated',
              environment: 'production'
            });
            
            // Comment on commit
            await github.rest.repos.createCommitComment({
              owner,
              repo,
              commit_sha: sha,
              body: `âŒ **Deployment Failed**\n\nThe deployment pipeline failed. Please check the logs and try again.\n\n**Failed Jobs:**\n${JSON.stringify(context.payload, null, 2)}`
            });

name: Simple Docker Deploy Pipeline

# Pipeline simplificado para desplegar solo la imagen Docker actualizada
on:
  push:
    branches:
      - main
  pull_request:
    branches:
      - main

env:
  AWS_DEFAULT_REGION: us-east-1
  ECR_REPOSITORY: amrize-ecr-repo
  IMAGE_TAG: ${{ github.sha }}

jobs:
  # Job 1: Build and Push Docker Image to ECR
  docker_build_push:
    name: "üöÄ Build & Deploy Docker Image"
    runs-on: ubuntu-latest
    
    outputs:
      image_uri: ${{ steps.build-image.outputs.image }}
      image_tag: ${{ steps.build-image.outputs.tag }}
      
    steps:
      - name: üì• Checkout Repository
        uses: actions/checkout@v4

      - name: üîê Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_DEFAULT_REGION }}

      - name: üîê Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: üìã Get ECR Repository Info
        id: ecr-info
        run: |
          ECR_URI=$(aws ecr describe-repositories \
            --repository-names ${{ env.ECR_REPOSITORY }} \
            --region ${{ env.AWS_DEFAULT_REGION }} \
            --query 'repositories[0].repositoryUri' \
            --output text)
          echo "üì¶ ECR Repository URI: $ECR_URI"
          echo "ecr_uri=$ECR_URI" >> $GITHUB_OUTPUT

      - name: üî® Build, Tag & Push Docker Image with Updated HTML
        id: build-image
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          ECR_REPOSITORY: ${{ env.ECR_REPOSITORY }}
          IMAGE_TAG: ${{ env.IMAGE_TAG }}
        run: |
          echo "üèóÔ∏è Building Docker image with updated HTML content..."
          echo "üìÑ HTML content will be copied from ./public-html/ to container"
          
          # Build image with commit SHA tag
          docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG .
          
          # Tag as latest
          docker tag $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG $ECR_REGISTRY/$ECR_REPOSITORY:latest
          
          echo "‚¨ÜÔ∏è Pushing images to ECR..."
          
          # Push both tags
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:latest
          
          echo "‚úÖ Images pushed successfully!"
          echo "üåê Image URI: $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG"
          
          # Set outputs
          echo "image=$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG" >> $GITHUB_OUTPUT
          echo "tag=$IMAGE_TAG" >> $GITHUB_OUTPUT

      - name: üßπ Cleanup Local Images
        run: |
          echo "üóëÔ∏è Cleaning up local Docker images..."
          docker rmi $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG || true
          docker rmi $ECR_REGISTRY/$ECR_REPOSITORY:latest || true
          docker system prune -f

  # Job 2: Update ECS Service with New Image
  ecs_update:
    name: "üîÑ Update ECS Service"
    runs-on: ubuntu-latest
    needs: docker_build_push
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    
    steps:
      - name: üîê Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_DEFAULT_REGION }}

      - name: üõ†Ô∏è Install jq
        run: |
          echo "üì¶ Installing jq for JSON manipulation..."
          sudo apt-get update && sudo apt-get install -y jq

      - name: üìã Check Current ECS Service Status
        run: |
          echo "üîç Checking current ECS service status..."
          aws ecs describe-services \
            --cluster cluster-backend-holcim-images \
            --services ui \
            --query 'services[0].{Status:status,RunningCount:runningCount,DesiredCount:desiredCount,CurrentImage:taskDefinition}' \
            --output table

      - name: ÔøΩ Create New Task Definition with Updated Image
        run: |
          echo "üìù Creating new task definition with image: ${{ needs.docker_build_push.outputs.image_uri }}"
          
          # Get current task definition
          CURRENT_TASK_DEF=$(aws ecs describe-services \
            --cluster cluster-backend-holcim-images \
            --services ui \
            --query 'services[0].taskDefinition' \
            --output text)
          
          echo "Current task definition: $CURRENT_TASK_DEF"
          
          # Get task definition details
          aws ecs describe-task-definition \
            --task-definition "$CURRENT_TASK_DEF" \
            --query 'taskDefinition' > current_task_def.json
          
          # Update the image in the container definition
          jq --arg image "${{ needs.docker_build_push.outputs.image_uri }}" \
             '.containerDefinitions[0].image = $image' \
             current_task_def.json > updated_task_def.json
          
          # Remove fields that shouldn't be in the new task definition
          jq 'del(.taskDefinitionArn, .revision, .status, .requiresAttributes, .placementConstraints, .compatibilities, .registeredAt, .registeredBy)' \
             updated_task_def.json > new_task_def.json
          
          # Register new task definition
          NEW_TASK_ARN=$(aws ecs register-task-definition \
            --cli-input-json file://new_task_def.json \
            --query 'taskDefinition.taskDefinitionArn' \
            --output text)
          
          echo "‚úÖ New task definition created: $NEW_TASK_ARN"
          echo "NEW_TASK_ARN=$NEW_TASK_ARN" >> $GITHUB_ENV

      - name: üîÑ Update ECS Service with New Task Definition
        run: |
          echo "üöÄ Updating ECS service with new task definition: $NEW_TASK_ARN"
          
          # Update service with new task definition
          aws ecs update-service \
            --cluster cluster-backend-holcim-images \
            --service ui \
            --task-definition "$NEW_TASK_ARN" \
            --force-new-deployment

      - name: ‚è≥ Wait for Service Stability
        run: |
          echo "‚è≥ Waiting for ECS service to stabilize with new image..."
          aws ecs wait services-stable \
            --cluster cluster-backend-holcim-images \
            --services ui \
            --cli-read-timeout 600 \
            --cli-connect-timeout 60

      - name: ‚úÖ Verify Service Update
        run: |
          echo "‚úÖ Verifying service deployment..."
          aws ecs describe-services \
            --cluster cluster-backend-holcim-images \
            --services ui \
            --query 'services[0].{Status:status,RunningCount:runningCount,DesiredCount:desiredCount,TaskDefinition:taskDefinition}' \
            --output table

  # Job 3: Verify Application is Running
  verify_deployment:
    name: "‚úÖ Verify Application"
    runs-on: ubuntu-latest
    needs: [docker_build_push, ecs_update]
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    
    steps:
      - name: üîê Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_DEFAULT_REGION }}

      - name: üåê Get Service URL and Test Application
        run: |
          echo "üîç Getting ECS service endpoint..."
          
          # Get target group ARN from service
          TG_ARN=$(aws ecs describe-services \
            --cluster cluster-backend-holcim-images \
            --services ui \
            --query 'services[0].loadBalancers[0].targetGroupArn' \
            --output text)
          
          if [ "$TG_ARN" != "None" ] && [ -n "$TG_ARN" ]; then
            echo "üéØ Target Group: $TG_ARN"
            
            # Get load balancer from target group
            LB_ARN=$(aws elbv2 describe-target-groups \
              --target-group-arns "$TG_ARN" \
              --query 'TargetGroups[0].LoadBalancerArns[0]' \
              --output text 2>/dev/null || echo "")
            
            if [ -n "$LB_ARN" ] && [ "$LB_ARN" != "None" ]; then
              # Get ALB DNS name
              ALB_DNS=$(aws elbv2 describe-load-balancers \
                --load-balancer-arns "$LB_ARN" \
                --query 'LoadBalancers[0].DNSName' \
                --output text 2>/dev/null || echo "")
              
              if [ -n "$ALB_DNS" ] && [ "$ALB_DNS" != "None" ]; then
                ALB_URL="http://$ALB_DNS"
                echo "üåê Testing application at: $ALB_URL"
                
                # Test endpoint with retries
                max_attempts=10
                attempt=0
                
                while [ $attempt -lt $max_attempts ]; do
                  attempt=$((attempt + 1))
                  echo "üîÑ Testing endpoint (attempt $attempt/$max_attempts)..."
                  
                  if curl -f -s "$ALB_URL" > /dev/null; then
                    echo "‚úÖ Application is responding successfully!"
                    echo "üìÑ Application content:"
                    curl -s "$ALB_URL" | head -10
                    break
                  else
                    echo "‚è≥ Waiting for application to be ready..."
                    sleep 15
                  fi
                done
              else
                echo "‚ö†Ô∏è Load balancer DNS not found"
              fi
            else
              echo "‚ö†Ô∏è Load balancer not found for target group"
            fi
          else
            echo "‚ö†Ô∏è No load balancer configured for this service"
            echo "‚úÖ Checking ECS service health instead..."
            aws ecs describe-services \
              --cluster cluster-backend-holcim-images \
              --services ui \
              --query 'services[0].{Status:status,HealthyTargets:runningCount,DesiredCount:desiredCount}' \
              --output table
          fi

      - name: üéâ Deployment Summary
        run: |
          echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
          echo "üéâ DEPLOYMENT COMPLETED SUCCESSFULLY! üéâ"
          echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
          echo ""
          echo "üì¶ Deployed Image: ${{ needs.docker_build_push.outputs.image_uri }}"
          echo "üè∑Ô∏è Image Tag: ${{ needs.docker_build_push.outputs.image_tag }}"
          echo "üîÑ ECS Service: ui updated"
          echo "üèóÔ∏è ECS Cluster: cluster-backend-holcim-images"
          echo ""
          echo "‚úÖ Updated HTML content deployed to production!"
          echo "üöÄ Application is ready to serve traffic!"
